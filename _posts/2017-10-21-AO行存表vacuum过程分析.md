---
title: AO行存表vacuum过程分析
date: 2017-10-21 23:00:00
categories:
- Greenplum
tags:
- Greenplum
---



# vacuum

analyze, vacuum的入口函数都是vacuum



对于每一个AO表vacuum分4个阶段处理：

- prepare phase
- compaction phase
- drop phase
- cleanup phase

每个阶段master修改VacuumStmt，并下发给segment，每个处理阶段都是一个2阶段的分布式事务

(vacuum -> vacuumStatement_Relation -> dispatchVacuum)



由于master 和 segment 用的是同一套代码，代码执行逻辑通过Gp_role变量进行区分，GP_ROLE_DISPATCH是master, GP_ROLE_EXECUTE是segment. 阅读代码时，请注意区分。



master执行vacuum，首先根据命令参数获取要处理的关系relations，例如"vacuum;"将对处理当前数据库中所有表，“vacuum table1”只处理table1，如果table1是分区表，则relations为根表及其所有分区表(table1, table1_part_1, table1_part_2, ...)。然后，遍历relations，对每一个表执行vacuumStatement_Relation()

```
/*
		 * Loop to process each selected relation.
		 */
		foreach(cur, relations)
		{
			Oid			relid = lfirst_oid(cur);

			if (vacstmt->vacuum)
				vacuumStatement_Relation(vacstmt, relid, relations, bstrategy, for_wraparound, isTopLevel);
            ...
        }
```



vacuumStatement_Relation中while (!getnextrelation)，当个relation的4个阶段没有处理完时，getnextrelation为false，将在循环中处理各个阶段，处理完一个关系后getnextrelation置为true

```
	while (!getnextrelation)
	{
	    ...
	    
		if (Gp_role != GP_ROLE_EXECUTE)
		{
			/*
			 * Keep things generated by this QD decision beyond a transaction.
			 */
			oldctx = MemoryContextSwitchTo(vac_context);
			if (RelationIsHeap(onerel))
			{
				...
			}
			/* the rest is about AO tables */
			else if (vacstmt->appendonly_compaction_vacuum_prepare) //prepare阶段
			{
				getnextrelation = false;
				dropPhase = false;
			}
			else if (!dropPhase) //compaction阶段，以及判断是否进入cleanup阶段
			{
			    //这个方法里判断是否进入cleanup阶段
				if (!vacuumStatement_AssignAppendOnlyCompactionInfo(vacstmt,
							onerel, compactedSegmentFileList,
							insertedSegmentFileList, &getnextrelation))
				{
					MemoryContextSwitchTo(oldctx);
					/* Nothing left to do for this relation */
					relation_close(onerel, NoLock);
					CommitTransactionCommand();
					/* don't dispatch this iteration */
					continue;
				}

                //compaction阶段, dropPhase将置为true
				compactedSegmentFileList =
					list_union_int(compactedSegmentFileList,
						vacstmt->appendonly_compaction_segno);
				insertedSegmentFileList =
					list_union_int(insertedSegmentFileList,
						vacstmt->appendonly_compaction_insert_segno);

				dropPhase = !getnextrelation;
			}
			else
			{   //drop阶段，dropPhase将置为false
				...
				RegisterSegnoForCompactionDrop(relid, vacstmt->appendonly_compaction_segno);
				list_free(vacstmt->appendonly_compaction_insert_segno);
				vacstmt->appendonly_compaction_insert_segno = NIL;
				dropPhase = false;
				getnextrelation = false;
			}
			MemoryContextSwitchTo(oldctx);
            ...
		}

        ...

		/*
		 * If we are in the dispatch mode, dispatch this modified
		 * vacuum statement to QEs, and wait for them to finish.
		 */
		if (Gp_role == GP_ROLE_DISPATCH)
		{
			...
			dispatchVacuum(vacstmt, &stats_context);
		}
   ...
   }
```





Compaction阶段

QD:

vacuum -> vacuumStatement_Relation() -> vacuumStatement_AssignAppendOnlyCompactionInfo

QE:

```
#0  AppendOnlySegmentFileFullCompaction (aorel=0x7fbe26bc4150, insertDesc=0x292b8c8, fsinfo=0x2983628) at appendonly_compaction.c:338
#1  0x00000000005534b7 in AppendOnlyCompact (aorel=0x7fbe26bc4150, compaction_segno=0x2980d60, insert_segno=2, isFull=0 '\000') at appendonly_compaction.c:715
#2  0x0000000000695973 in vacuum_appendonly_rel (aorel=0x7fbe26bc4150, vacstmt=0x289ca90) at vacuumlazy.c:1329
#3  0x00000000006939bc in lazy_vacuum_aorel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, updated_stats=0x7fff97bd7bf0) at vacuumlazy.c:397
#4  0x000000000069339a in lazy_vacuum_rel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, bstrategy=0x297dd20, updated_stats=0x7fff97bd7bf0) at vacuumlazy.c:235
#5  0x000000000068bfc2 in vacuum_rel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, lmode=1, updated_stats=0x7fff97bd7bf0, for_wraparound=0 '\000') at vacuum.c:2004
#6  0x000000000068aee4 in vacuumStatement_Relation (vacstmt=0x289ca90, relid=16430, relations=0x297dde0, bstrategy=0x297dd20, for_wraparound=0 '\000', isTopLevel=1 '\001') at vacuum.c:1254
#7  0x000000000068a210 in vacuum (vacstmt=0x290aaa0, relids=0x0, bstrategy=0x297dd20, for_wraparound=0 '\000', isTopLevel=1 '\001') at vacuum.c:528
#8  0x0000000000873b13 in ProcessUtility (parsetree=0x290aaa0, queryString=0x285e23e "VACUUM ao1;", params=0x0, isTopLevel=1 '\001', dest=0x285ea88, completionTag=0x7fff97bd8220 "") at utility.c:1532
#9  0x000000000087080a in PortalRunUtility (portal=0x28d3b50, utilityStmt=0x290aaa0, isTopLevel=1 '\001', dest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1424
#10 0x0000000000870a15 in PortalRunMulti (portal=0x28d3b50, isTopLevel=1 '\001', dest=0x285ea88, altdest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1517
#11 0x000000000086ff8c in PortalRun (portal=0x28d3b50, count=9223372036854775807, isTopLevel=1 '\001', dest=0x285ea88, altdest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1057
#12 0x0000000000867c75 in exec_mpp_query (query_string=0x285e23e "VACUUM ao1;", serializedQuerytree=0x285e24a "q", serializedQuerytreelen=56, serializedPlantree=0x0, serializedPlantreelen=0, 
    serializedParams=0x0, serializedParamslen=0, serializedQueryDispatchDesc=0x0, serializedQueryDispatchDesclen=0, seqServerHost=0x285e282 "10.244.0.11", seqServerPort=56493, localSlice=-1) at postgres.c:1375
#13 0x000000000086d74f in PostgresMain (argc=1, argv=0x279bd88, dbname=0x279bd40 "zlytest", username=0x277ad90 "gpadmin") at postgres.c:5138
#14 0x000000000080cf7e in BackendRun (port=0x27a99a0) at postmaster.c:6681
#15 0x000000000080c6ab in BackendStartup (port=0x27a99a0) at postmaster.c:6368
#16 0x0000000000805e45 in ServerLoop () at postmaster.c:2453
#17 0x00000000008047f2 in PostmasterMain (argc=15, argv=0x2776030) at postmaster.c:1537
#18 0x000000000072c060 in main (argc=15, argv=0x2776030) at main.c:206
```

AppendOnlyCompact遍历segmeng file，对需要清理的segmeng file上AccessExclusiveLock，如果该segmeng file上失效的数据大于清理阈值，则调用AppendOnlySegmentFileFullCompaction函数对该segmeng file进行清理，并将该segmeng file的状态标记为AOSEG_STATE_AWAITING_DROP。在接下来的Drop阶段，会处理这些标记为AOSEG_STATE_AWAITING_DROP的segment file.

```
		/*
		 * Try to get the transaction write-lock for the Append-Only segment file.
		 *
		 * NOTE: This is a transaction scope lock that must be held until commit / abort.
		 */
		 //做完compact会执行一次commit
		LockRelationAppendOnlySegmentFile(
												&aorel->rd_node,
												segfile_array[i]->segno,
												AccessExclusiveLock,
												false);
		if (AppendOnlyCompaction_ShouldCompact(aorel,
				fsinfo->segno, fsinfo->total_tupcount, isFull))
		{
			AppendOnlySegmentFileFullCompaction(aorel,
				insertDesc, 
				fsinfo);
		} 
```



Drop阶段

```
#0  AppendOnlyDrop (aorel=0x7fbe26bc4150, compaction_segno=0x2970d00) at appendonly_compaction.c:512
#1  0x0000000000695865 in vacuum_appendonly_rel (aorel=0x7fbe26bc4150, vacstmt=0x289ca90) at vacuumlazy.c:1307
#2  0x00000000006939bc in lazy_vacuum_aorel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, updated_stats=0x7fff97bd7bf0) at vacuumlazy.c:397
#3  0x000000000069339a in lazy_vacuum_rel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, bstrategy=0x296dcc0, updated_stats=0x7fff97bd7bf0) at vacuumlazy.c:235
#4  0x000000000068bfc2 in vacuum_rel (onerel=0x7fbe26bc4150, vacstmt=0x289ca90, lmode=1, updated_stats=0x7fff97bd7bf0, for_wraparound=0 '\000') at vacuum.c:2004
#5  0x000000000068aee4 in vacuumStatement_Relation (vacstmt=0x289ca90, relid=16430, relations=0x296dd80, bstrategy=0x296dcc0, for_wraparound=0 '\000', isTopLevel=1 '\001') at vacuum.c:1254
#6  0x000000000068a210 in vacuum (vacstmt=0x290aaa0, relids=0x0, bstrategy=0x296dcc0, for_wraparound=0 '\000', isTopLevel=1 '\001') at vacuum.c:528
#7  0x0000000000873b13 in ProcessUtility (parsetree=0x290aaa0, queryString=0x285e23e "VACUUM ao1;", params=0x0, isTopLevel=1 '\001', dest=0x285ea88, completionTag=0x7fff97bd8220 "") at utility.c:1532
#8  0x000000000087080a in PortalRunUtility (portal=0x28d3b50, utilityStmt=0x290aaa0, isTopLevel=1 '\001', dest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1424
#9  0x0000000000870a15 in PortalRunMulti (portal=0x28d3b50, isTopLevel=1 '\001', dest=0x285ea88, altdest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1517
#10 0x000000000086ff8c in PortalRun (portal=0x28d3b50, count=9223372036854775807, isTopLevel=1 '\001', dest=0x285ea88, altdest=0x285ea88, completionTag=0x7fff97bd8220 "") at pquery.c:1057
#11 0x0000000000867c75 in exec_mpp_query (query_string=0x285e23e "VACUUM ao1;", serializedQuerytree=0x285e24a "i", serializedQuerytreelen=52, serializedPlantree=0x0, serializedPlantreelen=0, 
    serializedParams=0x0, serializedParamslen=0, serializedQueryDispatchDesc=0x0, serializedQueryDispatchDesclen=0, seqServerHost=0x285e27e "10.244.0.11", seqServerPort=56493, localSlice=-1) at postgres.c:1375
#12 0x000000000086d74f in PostgresMain (argc=1, argv=0x279bd88, dbname=0x279bd40 "zlytest", username=0x277ad90 "gpadmin") at postgres.c:5138
#13 0x000000000080cf7e in BackendRun (port=0x27a99a0) at postmaster.c:6681
#14 0x000000000080c6ab in BackendStartup (port=0x27a99a0) at postmaster.c:6368
#15 0x0000000000805e45 in ServerLoop () at postmaster.c:2453
#16 0x00000000008047f2 in PostmasterMain (argc=15, argv=0x2776030) at postmaster.c:1537
#17 0x000000000072c060 in main (argc=15, argv=0x2776030) at main.c:206
```

AppendOnlyDrop遍历segmeng file, 对状态为AOSEG_STATE_AWAITING_DROP的segment file进行处理：

在AppendOnlyCompaction_DropSegmentFile中做两个事情，1、告诉存储管理器待移除(PedingDelete)该segment file，等事务提交的时候会删除；2、删除该segment file在元数据表gp_relation_node中对应的记录

在ClearFileSegInfo中，将该segment file在元数据表中对应的记录的eof, tupcount, modcount等字段清理，并把状态由AOSEG_STATE_AWAITING_DROP改为AOSEG_STATE_DEFAULT。

```
		/*
		 * Try to get the transaction write-lock for the Append-Only segment file.
		 *
		 * NOTE: This is a transaction scope lock that must be held until commit / abort.
		 */
		 //执行完Drop会执行一次commit
		LockRelationAppendOnlySegmentFile(
												&aorel->rd_node,
												segfile_array[i]->segno,
												AccessExclusiveLock,
												false);

		/* Re-fetch under the write lock to get latest committed eof. */
		fsinfo = GetFileSegInfo(aorel, SnapshotNow, segno);

		if (fsinfo->state == AOSEG_STATE_AWAITING_DROP)
		{
			Assert(HasLockForSegmentFileDrop(aorel));
			Assert(!HasSerializableBackends(false));
			AppendOnlyCompaction_DropSegmentFile(aorel, segno);
			ClearFileSegInfo(aorel, segno,
					AOSEG_STATE_DEFAULT);
		}
```

